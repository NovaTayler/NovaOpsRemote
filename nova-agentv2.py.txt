#!/usr/bin/env python3 import os import time import random import string import asyncio import aiohttp import json import hashlib import logging import structlog import asyncpg import aioredis import redis import paypalrestsdk import stripe import requests import base64 import imaplib import email import re import uuid import shutil import psutil from typing import Dict, Optional, Tuple from datetime import datetime, timedelta from tenacity import retry, stop_after_attempt, wait_exponential from pydantic import BaseModel, validator from cryptography.fernet import Fernet from prometheus_client import Counter, Gauge, start_http_server from fastapi import FastAPI, HTTPException, Depends, File, UploadFile, WebSocket from fastapi.security import OAuth2PasswordBearer from fastapi.middleware.cors import CORSMiddleware from slowapi import Limiter, _rate_limit_exceeded_handler from slowapi.util import get_remote_address from slowapi.errors import RateLimitExceeded from celery import Celery from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.common.by import By from selenium.webdriver.chrome.options import Options from webdriver_manager.chrome import ChromeDriverManager from dotenv import load_dotenv from bitcoinlib.wallets import Wallet from fake_useragent import UserAgent from textblob import TextBlob from jwt import encode, decode, PyJWTError from whispersec import VaultManager # Load environment variables load_dotenv() # Initialize logging structlog.configure( processors=[ structlog.stdlib.filter_by_level, structlog.processors.TimeStamper(fmt="iso"), structlog.processors.JSONRenderer(), ], logger_factory=structlog.stdlib.LoggerFactory(), ) logger = structlog.get_logger() logging.basicConfig(filename='humanitas.log', level=logging.INFO) # Metrics start_http_server(8001) REQUESTS_TOTAL = Counter('requests_total', 'Total requests') ACCOUNTS_CREATED = Gauge('accounts_created', 'Number of accounts created') FAILED_TASKS = Counter('failed_tasks', 'Failed Celery tasks') PAYMENTS_PROCESSED = Counter('payments_processed', 'Total payments processed') LISTINGS_ACTIVE = Gauge('listings_active', 'Active listings') ORDERS_FULFILLED = Counter('orders_fulfilled', 'Orders fulfilled') # Celery setup app_celery = Celery('humanitas', broker='redis://redis:6379/0', backend='redis://redis:6379/1') app_celery.conf.task_reject_on_worker_lost = True app_celery.conf.task_acks_late = True # Redis client for pub/sub redis_client = redis.Redis(host='redis', port=6379, decode_responses=True) # FastAPI setup app = FastAPI() limiter = Limiter(key_func=get_remote_address) app.state.limiter = limiter app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler) app.add_middleware( CORSMiddleware, allow_origins=["http://localhost:5000"], allow_credentials=True, allow_methods=["*"], allow_headers=["*"], ) oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login") # Configuration class Config: DB_USER = os.getenv("DB_USER", "postgres") DB_PASSWORD = os.getenv("DB_PASSWORD", "password") DB_NAME = os.getenv("DB_NAME", "humanitas") DB_HOST = os.getenv("DB_HOST", "postgres") SUPPLIERS = os.getenv("SUPPLIERS", "Payoneer,Stripe,Paypal,CJ Dropshipping,AliExpress").split(",") PLATFORMS = ["eBay", "Amazon", "Walmart", "Etsy", "Shopify"] RATE_LIMIT_DELAY = float(os.getenv("RATE_LIMIT_DELAY", 2.0)) MAX_LISTINGS = int(os.getenv("MAX_LISTINGS", 500)) EMAIL_PROVIDER = os.getenv("EMAIL_PROVIDER", "imap.gmail.com") EMAIL_USER = os.getenv("EMAIL_USER") EMAIL_PASS = os.getenv("EMAIL_PASS") config = Config() # WhisperSec VaultManager vault_manager = VaultManager() # AI Routing Logic def run_brain(prompt: str) -> str: try: # Local Ollama res = requests.post("http://localhost:11434/api/generate", json={ "model": "deepseek-coder", "prompt": prompt, "stream": False }, timeout=20) return res.json().get("response", "") except Exception: # Groq fallback groq_key = vault_manager.get_secret("groq_key") or os.getenv("GROQ_KEY") if not groq_key: raise Exception("No Groq key available") res = requests.post("https://api.groq.com/openai/v1/chat/completions", headers={ "Authorization": f"Bearer {groq_key}" }, json={ "model": "mixtral-8x7b", "messages": [{"role": "user", "content": prompt}] }) return res.json()["choices"][0]["message"]["content"] # Database async def get_db_connection(): return await asyncpg.connect( user=config.DB_USER, password=config.DB_PASSWORD, database=config.DB_NAME, host=config.DB_HOST ) async def init_db(): conn = await get_db_connection() await conn.execute(''' CREATE TABLE IF NOT EXISTS accounts ( platform TEXT, email TEXT PRIMARY KEY, username TEXT, password TEXT, status TEXT, token TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ''') await conn.execute(''' CREATE TABLE IF NOT EXISTS supplier_accounts ( supplier TEXT, email TEXT, password TEXT, api_key TEXT, net_terms TEXT, PRIMARY KEY (supplier, email) ) ''') await conn.execute(''' CREATE TABLE IF NOT EXISTS listings ( sku TEXT PRIMARY KEY, platform TEXT, title TEXT, price REAL, supplier TEXT, status TEXT ) ''') await conn.execute(''' CREATE TABLE IF NOT EXISTS orders ( order_id TEXT PRIMARY KEY, platform TEXT, sku TEXT, buyer_name TEXT, buyer_address TEXT, status TEXT, supplier TEXT, fulfilled_at TIMESTAMP ) ''') await conn.execute(''' CREATE TABLE IF NOT EXISTS users ( email TEXT PRIMARY KEY, password TEXT, role TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ) ''') await conn.execute(''' CREATE TABLE IF NOT EXISTS bot_runs ( run_id TEXT PRIMARY KEY, bot_name TEXT, execution_time REAL, errors INTEGER, last_run TIMESTAMP, status TEXT ) ''') await conn.close() async def track_bot_run(bot_name: str, execution_time: float, errors: int, status: str): run_id = str(uuid.uuid4()) conn = await get_db_connection() await conn.execute( "INSERT INTO bot_runs (run_id, bot_name, execution_time, errors, last_run, status) VALUES ($1, $2, $3, $4, $5, $6)", (run_id, bot_name, execution_time, errors, datetime.utcnow(), status) ) await conn.close() # Models class Product(BaseModel): title: str sku: str cost: float price: float url: str quantity: int supplier: str class AccountInput(BaseModel): email: str password: str phone: str @validator('email') def email_valid(cls, v): if '@' not in v or '.' not in v: raise ValueError('Invalid email format') return v # Utilities ua = UserAgent() async def get_random_user_agent() -> str: return ua.random class ProxyManager: def __init__(self): self.proxies = asyncio.run(self.fetch_proxy_list()) self.session_proxies = {} def rotate(self, session_id: str) -> Dict[str, str]: if not self.proxies: logger.warning("No proxies available") return {} if session_id not in self.session_proxies: self.session_proxies[session_id] = random.choice(self.proxies) proxy = self.session_proxies[session_id] return {'http': f'http://{proxy}', 'https': f'http://{proxy}'} async def fetch_proxy_list(self) -> list: REQUESTS_TOTAL.inc() async with aiohttp.ClientSession() as session: url = "https://api.proxyscrape.com/v2/?request=displayproxies&protocol=http&timeout=10000" async with session.get(url) as resp: if resp.status == 200: return (await resp.text()).splitlines()[:50] return [] proxy_manager = ProxyManager() async def human_like_typing(element, text): for char in text: element.send_keys(char) await asyncio.sleep(random.uniform(0.05, 0.3)) async def generate_email() -> str: domain = os.getenv("DOMAIN", "gmail.com") user = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10)) return f"{user}@{domain}" async def solve_captcha(site_key: str, url: str) -> Optional[str]: REQUESTS_TOTAL.inc() async with aiohttp.ClientSession() as session: captcha_url = "http://2captcha.com/in.php" params = {"key": os.getenv("CAPTCHA_API_KEY"), "method": "userrecaptcha", "googlekey": site_key, "pageurl": url} async with session.post(captcha_url, data=params) as resp: text = await resp.text() if "OK" not in text: return None captcha_id = text.split("|")[1] for _ in range(10): await asyncio.sleep(5) async with session.get(f"http://2captcha.com/res.php?key={os.getenv('CAPTCHA_API_KEY')}&action=get&id={captcha_id}") as resp: text = await resp.text() if "OK" in text: return text.split("|")[1] return None async def get_virtual_phone() -> str: REQUESTS_TOTAL.inc() twilio_key = os.getenv("TWILIO_API_KEY") if not twilio_key: return f"+1555{random.randint(1000000, 9999999)}" async with aiohttp.ClientSession(headers={"Authorization": f"Basic {base64.b64encode(twilio_key.encode()).decode()}"}) as session: url = f"https://api.twilio.com/2010-04-01/Accounts/{twilio_key.split(':')[0]}/IncomingPhoneNumbers.json" async with session.post(url, data={"AreaCode": "555"}) as resp: if resp.status == 201: return (await resp.json())["phone_number"] return f"+1555{random.randint(1000000, 9999999)}" async def fetch_otp(email: str, subject_filter: str = "verification") -> str: REQUESTS_TOTAL.inc() mail = imaplib.IMAP4_SSL(config.EMAIL_PROVIDER) mail.login(config.EMAIL_USER, config.EMAIL_PASS) mail.select("inbox") for _ in range(10): status, messages = mail.search(None, f'(UNSEEN SUBJECT "{subject_filter}")') if status == "OK" and messages[0]: latest_email_id = messages[0].split()[-1] _, msg_data = mail.fetch(latest_email_id, "(RFC822)") raw_email = msg_data[0][1] email_message = email.message_from_bytes(raw_email) for part in email_message.walk(): if part.get_content_type() == "text/plain": body = part.get_payload(decode=True).decode() otp = re.search(r'\b\d{6}\b', body) if otp: mail.logout() return otp.group() await asyncio.sleep(5) mail.logout() raise Exception("OTP retrieval failed") async def generate_ai_description(title: str) -> str: blob = TextBlob(title) adjectives = ["Premium", "High-Quality", "Durable", "Stylish"] adverbs = ["Effortlessly", "Seamlessly", "Perfectly"] return f"{random.choice(adverbs)} enhance your experience with this {random.choice(adjectives)} {blob.noun_phrases[0]}." # Dropshipping Functions @retry(stop=stop_after_attempt(3)) async def process_payment(amount: float, credentials: str, destination: str = "final") -> bool: REQUESTS_TOTAL.inc() PAYMENTS_PROCESSED.inc() payment_method = os.getenv("PAYMENT_METHOD", "payoneer") if destination == "final": if os.getenv("FINAL_PAYMENT_METHOD") == "paypal": paypalrestsdk.configure({ "mode": "live", "client_id": os.getenv("PAYPAL_CLIENT_ID"), "client_secret": os.getenv("PAYPAL_CLIENT_SECRET") }) payment = paypalrestsdk.Payment({ "intent": "sale", "payer": {"payment_method": "paypal"}, "transactions": [{"amount": {"total": str(amount), "currency": "USD"}}], "redirect_urls": {"return_url": "http://localhost", "cancel_url": "http://localhost"} }) return payment.create() elif os.getenv("FINAL_PAYMENT_METHOD") == "crypto": wallet = Wallet.create(os.getenv("BTC_WALLET_NAME", "humanitas_wallet")) if wallet.balance() < amount * 100000000: return False wallet.send_to(os.getenv("BTC_WALLET_ADDRESS"), int(amount * 100000000)) return True else: if payment_method == "payoneer": payoneer_email, payoneer_api_key = credentials.split(":") headers = {"Authorization": f"Bearer {payoneer_api_key}", "Content-Type": "application/json"} payload = {"amount": amount, "currency": "USD", "recipient_email": payoneer_email} async with aiohttp.ClientSession(headers=headers) as session: async with session.post(f"https://api.payoneer.com/v2/programs/{os.getenv('PAYONEER_PROGRAM_ID')}/payouts", json=payload) as resp: return resp.status == 200 elif payment_method == "stripe": stripe_email, stripe_api_key = credentials.split(":") stripe.api_key = stripe_api_key charge = stripe.Charge.create( amount=int(amount * 100), currency="usd", source=os.getenv("STRIPE_SOURCE_TOKEN"), description=f"Signup: ${amount}" ) return True @app_celery.task(bind=True) @retry(stop=stop_after_attempt(5)) async def create_platform_account(self, platform: str, index: int) -> Tuple[Optional[str], Optional[str]]: REQUESTS_TOTAL.inc() ACCOUNTS_CREATED.inc() try: email = await generate_email() username = f"{platform.lower()}user{index}{random.randint(100, 999)}" password = ''.join(random.choices(string.ascii_letters + string.digits, k=12)) phone = await get_virtual_phone() AccountInput(email=email, password=password, phone=phone) signup_urls = { "eBay": "https://signup.ebay.com/pa/register", "Amazon": "https://sellercentral.amazon.com/register", "Walmart": "https://marketplace.walmart.com/us/seller-signup", "Etsy": "https://www.etsy.com/sell", "Shopify": "https://www.shopify.com/signup" } session_id = f"{platform}_{email}" token = None if platform == "eBay": payload = {"email": email, "password": password, "firstName": f"User{index}", "lastName": "Auto", "phone": phone} headers = {"User-Agent": await get_random_user_agent()} async with aiohttp.ClientSession(headers=headers) as session: async with session.get(signup_urls[platform], proxy=proxy_manager.rotate(session_id)["http"]) as resp: captcha_response = await solve_captcha(os.getenv("EBAY_SITE_KEY"), signup_urls[platform]) if captcha_response: payload["g-recaptcha-response"] = captcha_response async with session.post(signup_urls[platform], data=payload, proxy=proxy_manager.rotate(session_id)["http"]) as resp: if resp.status != 200: raise Exception("eBay signup failed") token = await fetch_ebay_token(email, password) else: options = Options() options.add_argument("--headless") options.add_argument(f"--user-agent={await get_random_user_agent()}") proxy = proxy_manager.rotate(session_id) if proxy: options.add_argument(f'--proxy-server={proxy["http"]}') driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options) try: driver.get(signup_urls[platform]) email_field = driver.find_element(By.CSS_SELECTOR, "input[type='email']") password_field = driver.find_element(By.CSS_SELECTOR, "input[type='password']") await human_like_typing(email_field, email) await human_like_typing(password_field, password) driver.find_element(By.XPATH, "//button[@type='submit']").click() time.sleep(5) otp = await fetch_otp(email, f"{platform} Verification") if otp: otp_field = driver.find_element(By.CSS_SELECTOR, "input[placeholder*='code']") await human_like_typing(otp_field, otp) driver.find_element(By.XPATH, "//button[@type='submit']").click() token = driver.find_element(By.CSS_SELECTOR, "input[name='api_token']").get_attribute("value") finally: driver.quit() conn = await get_db_connection() await conn.execute("INSERT OR IGNORE INTO accounts (platform, email, username, password, status, token) VALUES ($1, $2, $3, $4, $5, $6)", (platform, email, username, password, "active", token)) await conn.close() vault_manager.store_secret(f"{platform}_EMAIL", email) vault_manager.store_secret(f"{platform}_TOKEN", token) return username, token except Exception as e: FAILED_TASKS.inc() raise self.retry(exc=e) async def fetch_ebay_token(email: str, password: str) -> str: options = Options() options.add_argument("--headless") driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options) try: driver.get("https://signin.ebay.com") await human_like_typing(driver.find_element(By.ID, "userid"), email) await human_like_typing(driver.find_element(By.ID, "pass"), password) driver.find_element(By.ID, "sgnBt").click() driver.get("https://developer.ebay.com/my/auth?env=production") return driver.find_element(By.XPATH, "//textarea[contains(@class, 'oauth-token')]").text finally: driver.quit() @retry(stop=stop_after_attempt(3)) async def fetch_products() -> list: REQUESTS_TOTAL.inc() suppliers = ["CJ Dropshipping", "AliExpress"] all_products = [] cache = await aioredis.create_redis_pool('redis://redis:6379') for supplier in suppliers: cached = await cache.get(f"products:{supplier}") if cached: all_products.extend(json.loads(cached)) continue api_key = vault_manager.get_secret(f"{supplier}_API_KEY") products = [] # Simplified for brevity await cache.set(f"products:{supplier}", json.dumps(products), expire=3600) all_products.extend(products) await cache.close() return all_products(products) def list_products(): products = [] return products @retry(stop=stop_after_attempt(3)) async def list_product_on_platform(product: Dict, platform: str) -> bool: REQUESTS_TOTAL.inc() LISTINGS_ACTIVE.inc() try: token = vault_manager.get_secret(f"{platform}_TOKEN") if not token: raise ValueError(f"No token found for {platform}") headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json", "User-Agent": await get_random_useragent()} desc = await generate_ai_description(product["title"]) url = f"https://api.{platform.lower()}.com/sell/inventory/v1/offer" payload = { "sku": product["sku"], "marketplaceId": f"{platform.upper()}_US", "listingDescription": desc, "pricingSummary": {"price": {"value": str(product["price"]), "currency": "USD"}}, "availableQuantity": product["quantity"] } async with aiohttp.ClientSession(headers=headers) as session: async with session.post(url, json=payload) as resp: if resp.status in [200, 201]: conn = await get_db_connection() await conn.execute( "INSERT OR OR REPLACE INTO listings (sku, platform, title, price, supplier, status) VALUES ($1, $2, $3, $4, $5, $6)", (product["sku"], platform, product["title"], product["price"], product["supplier"], "active") ) await conn.close() logger.info(f"Listed {product["title"]} on {platform}", price=product["price"]) return True logger.error(f"Failed to to list on {platform}: {await resp.text()}") raise Exception(f"Failed to list to list on {platform}") except Exception as e: logger.error(f"Listing failed: {str(e)}") raise e @retry(stop=stop_after_attempt(3)) async def fulfill_order(order_id: str, platform: str, sku: str, buyer_name: str, buyer_address: str, supplier: str) -> bool: REQUESTS_TOTAL.inc() ORDERS_FULFILLED.inc() try: conn = await get_db_connection() listing = await conn.fetchrow("SELECT * FROM listings WHERE sku = $1 AND platform = $2", sku, platform) if not listing: logger.error(f"No matching listing found for SKU {sku} on {platform}") raise Exception("Listing not found") api_key = vault_manager.get_secret(f"{supplier}_API_KEY") if not api_key: logger.error(f"No API key found for {supplier}") raise Exception("API key missing") urls = { "CJ Dropshipping": "https://developers.cjdropshipping.com/api2.0/order/create", "AliExpress": "https://api.aliexpress.com/v1/order/place} headers = {"Authorization": f"Bearer {api_key}", "Content-Type": "application/json", "User-Agent": await get_random_useragent()} payload = { "order_id": order_id, "sku": sku, "buyer_name": buyer_name, "buyer_address": buyer_address, "quantity": 1 } async with aiohttp.ClientSession(headers=headers) as session: async with session.post(urls[supplier], json=payload) as resp: if resp.status == 200: await conn.execute("UPDATE orders SET status = 'fulfilled', fulfilled_at = CURRENT_TIMESTAMP WHERE order_id = $1", order_id) await conn.close() logger.info(f"Fulfilled order {order_id} via {supplier}") return True logger.error(f"Failed to to fulfill order {order_id}: {await resp.text()}") raise Exception("errorOrder fulfillment failed") except Exception: logger.error(f"Fulfillment error for order {order_id}: {str(e)}") await conn.close() raise e # API Endpoints @app.get("/api/nodes") @limiter.limit("10/minute") async def get_nodes(token: str = Depends(oauth2_scheme)): if not await vault_manager.validate_token(token): raise HTTPException(status_code=401, detail="Unauthorized") redis_pool = await aioredis.create_redis_pool('redis://redis://redis:6379/5') nodes = [] async for key in redis_pool.keys("node:*"): node_data = await redis_pool.hgetall(key) nodes.append({"id": key.decode().split(":")[1], **node_data}) await redis_pool.close() return nodes @app.get("/api/bots/status") @limiter.limit("10/minute")) async def get_bots_status(token: str = Depends(oauth2_scheme)): try: if not await vault_manager.validate_token(token): raise HTTPException(status_code="401, detail="Unauthorized") conn = await get_db_connection() try: bots = await conn.fetch("SELECT bot_name, last_run, status, execution_time, errors FROM bot_status ORDER BY last_run DESC") finally: await conn.close() return {"bots": [{"name": bot["bot_name"], "last_run": bot["last_run"].isoformat() if bot["last_run"] else "N/A", "status": bot["status"], "execution_time": bot["execution_time"], "errors": bot["errors"]} for bot in bots]} except Exception as e: logger.error("Failed to fetch bot status", error=str(e)) raise HTTPException(status_code="500", detail="Internal server error") @app.post("/api/deploy/{bot_name}") @limiter.limit("5/minute") async def deploy_bot(bot: str, token: str = Depends(oauth2_scheme)): try: if not await vault_manager.validate_token(token): raise HTTPException(status_code=401, detail="Unauthorized") bot_path = f"bots/{bot_name}.py" if not os.path.exists(bot_path): logger.error("Bot file not found", bot_path=bot_path) raise HTTPException(status_code="404, detail="Bot not found") redis_client.publish(f"nova:deploy:{bot_name}", json.dumps({"path": bot_path})) await track_bot_run(bot_name, 0, {"0", "Deployed"}) logger.info("Bot deployment triggered", bot=bot_name) return {"message": f"Deployed {bot_name}"} except Exception as e: logger.error("Bot deployment failed", bot=bot_name, error=str(e)) raise HTTPException(status_code=500", detail=f"Deployment failed: {str(e)}") @app.post("/api/bots/upload") @limiter.limit("5/minute") async def upload_bot(file: UploadFile = File(...), token: str = Depends(oauth2_scheme)): try: if not await vault_manager.validate_token(token): raise HTTPException(status_code=401", detail="Unauthorized") bot_name = f"bot_{{uuid.uuid4().hex[:8]}".py}" bot_path = os.path.join("bots", bot_name) os.makedirs("bots", exist_ok=True) with open(bot_path, "wb") as f: shutil.copyfileobj(file.file, f) await track_bot_run(bot_name, 0, 0, "Uploaded") logger.info("Bot uploaded successfully", bot=bot_name) return {"message": "Successfully uploaded {bot_name}"} except Exception as e: logger.error("Bot upload failed", error=str(e)) raise HTTPException(status_code="500", detail=f"Upload failed: {str(e)}")) @app.get("/api/brain/assign") @limiter.limit("5/minute") async def assign_brain_task(payload: dict, token: str = Depends(oauth2_scheme)): try: if not await vault_manager.validate_token(token): raise HTTPException(status_code="401", detail="Unauthorized") prompt = payload.get("prompt", "") if not prompt: raise HTTPException(status_code="400", detail="Prompt required") result = await run_brain(prompt) logger.info("Brain task executed", prompt=prompt[:50]) return {"result": result} except Exception as e: logger.error("Brain task failed", error=str(e)) raise HTTPException(status_code=500, detail=f"Brain task failed: {str(e)}")) @app.get("/api/health") async def health(): return await {"status": "healthy"} @app.websocket("/api/ws/bots/{bot_name}") async def websocket_bot_feed(websocket: WebSocket, bot_name: str, token: str): try: if not await vault_manager.validate_token(token): await websocket.close(code=401) raise HTTPException(status_code=401, detail="Unauthorized") await websocket.accept() pubsub = redis_client.pubsub() pubsub.subscribe(f"nova:logs/{bot_name}") try: while True: try: message = pubsub.get_message() if message and message["type"] == "message": await websocket.send_text(message["data"]) await asyncio.sleep(0.1) except Exception as e: logger.error("WebSocket message failed", error=str(e)) break finally: pubsub.close() await websocket.close() except Exception as e: logger.error("WebSocket connection failed", error=str(e)) raise HTTPException(status_code=500, detail=f"WebSocket error: {str(e)}") @app.post("/auth/register") @limiter.limit("5/minute") async def register(email: str, password: str, role: str = "user"): try: await vault_manager.register_user(email, password, role) logger.info("User registered successfully", email=email) return {"message": "User registered"} except Exception as e: logger.error("User registration failed", error=str(e)) raise HTTPException(status_code=500, detail=f"Registration failed: {str(e)}")) @app.post("/auth/login") @limiter.limit("5/minute") async def login(email: str, password: str): try: token = await vault_manager.validate_user(email, password) if not token: logger.warning("Invalid login attempt", email=email) raise HTTPException(status_code=401, detail="Invalid credentials") logger.info("User logged in", email=email) return {"access_token": token, "token_type": "bearer"} except Exception as e: logger.error("Login failed", error=str(e)) raise HTTPException(status_code=500, detail=f"Login failed: {str(e)}")) # Background Tasks async def ping_nodes(): try: while True: redis_pool = await aioredis.create_pool('redis://redis://redis:6379/0') try: node_id = str(uuid.uuid4()) await redis_pool.hset(f"node:{node_id}", mapping={ "cpu": str(psutil.cpu_percent()), "ram": str(psutil.virtual_memory().percent), "last_seen": str(time.time()) }) await redis_pool.expire(f"node:{node_id}", expire_time=30) finally: redis_pool.close() await asyncio.sleep(5) except Exception as e: logger.error("Node ping failed", error=str(e)) async def update_metrics(): try: while True: redis_pool = await aioredis.create_pool('redis://redis://redis:6379/1') try: await redis_pool.set('node:cpu', str(psutil.cpu_percent())) await redis_pool.set('node:ram', str(psutil.virtual_memory().percent)) finally: redis_pool.close() await asyncio.sleep(30) except Exception: logger.error("Metrics update failed", error=str(e)) @app.on_event("startup") async def startup(): try: await init_db() logger.info("Database initialized") asyncio.create_task(ping_nodes()) asyncio.create_task(update_metrics()) logger.info("Background tasks started") except Exception as e: logger.error("Startup failed", error=str(e)) raise Exception("Failed to initialize system") if __name__ == '__main__': import uvicorn uvicorn.run(app, host="0.0.0.0", port=8000)

#!/usr/bin/env python3 import os import sys import json import redis import logging import structlog import subprocess import threading import time from importlib import import_module from pathlib import Path # Logging setup structlog.configure( processors=[ structlog.processors.TimeStamper(fmt="iso"), structlog.processors.JSONRenderer() ], logger_factory=structlog.stdlib.LoggerFactory(), ) logger = structlog.get_logger() # Redis connection redis_client = redis.Redis(host='redis', port=6379, decode_responses=True) pubsub = redis_client.pubsub() # NovaGhost Watcher def start_novaghost_watcher(): def ghost_loop(): while True: try: subprocess.run(["python3", "deploy/novaghost.py"], check=True, capture_output=True) except Exception as e: logger.error(f"[NovaGhost] Error: {e}") time.sleep(60) # Retry every minute thread = threading.Thread(target=ghost_loop, daemon=True) thread.start() def run_bot(bot_path: str, bot_name: str): try: bot_module = bot_name.replace('.py', '') sys.path.insert(0, str(Path(bot_path).parent)) module = import_module(bot_module) start_time = time.time() module.main() # Assumes bot has a main() function execution_time = time.time() - start_time redis_client.publish(f"nova:logs_{bot_name}", json.dumps({"status": "success", "execution_time": execution_time})) logger.info("Bot executed successfully", bot=bot_name, execution_time=execution_time) except Exception as e: redis_client.publish(f"nova:logs_{bot_name}", json.dumps({"status": "error", "error": str(e)})) logger.error("Bot execution failed", bot=bot_name, error=str(e)) raise def main(): pubsub.subscribe("nova:deploy:*") start_novaghost_watcher() logger.info("Agent started, listening for deploy tasks") for message in pubsub.listen(): if message["type"] == "message": try: channel = message["channel"] bot_name = channel.split(":")[2] data = json.loads(message["data"]) bot_path = data["path"] logger.info("Received deploy task", bot=bot_name, path=bot_path) run_bot(bot_path, bot_name) except Exception as e: logger.error("Error processing deploy task", error=str(e)) continue if __name__ == "__main__": main()

#!/usr/bin/env python3 import os import json import argparse from cryptography.fernet import Fernet from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC import base64 import logging import structlog structlog.configure( processors=[ structlog.processors.TimeStamper(fmt="iso"), structlog.processors.JSONRenderer() ], logger_factory=structlog.stdlib.LoggerFactory(), ) logger = structlog.get_logger() class VaultManager: def __init__(self, vault_file="secrets.vault", key_file="vault.key"): self.vault_file = vault_file self.key_file = key_file self.vault_data = {} self.cipher = self._init_cipher() self.load_vault() def _init_cipher(self): if not os.path.exists(self.key_file): key = Fernet.generate_key() with open(self.key_file, "wb") as f: key_file.write(key) else: with open(self.key_file, "rb") as f: key = f.read() return Fernet(key) def load_vault(self): if os.path.exists(self.vault_file): self.vault_data = {} self.save_vault() else: with open(self.vault_file, "rb") as f: encrypted = f.read() self.vault_data = json.loads(self.cipher.decrypt(encrypted).decode()) def save_vault(self): encrypted = self.cipher.encrypt(json.dumps(self.vault_data).encode()) with open(self.vault_file, "wb") as f: f.write(encrypted) def store_secret(self, key: str, value: str): self.vault_data[key] = self.cipher.encrypt(value.encode()).decode() self.save_vault() def get_secret(self, key: str) -> Optional[str]: encrypted = self.vault_data.get(key) return self.cipher.decrypt(encrypted.encode()).decode() if encrypted else None def register_user(self, email: str, password: str, role: str = "user"): try: hashed_password = hashlib.sha256(password.encode()).hexdigest() self.store_secret(f"auth_{email}", json.dumps({"password": hashed_password, "role": role})) logger.info("User registered", email=email) return True except Exception as e: logger.error("User registration failed", email=email, error=str(e)) return False def validate_user(self, password: str, email: str) -> Optional[str]: try: user_data = self.get_secret(f"auth_{email}") if not user_data: return None user = json.loads(user_data) if hashlib.sha256(password.encode()).hexdigest() == user["password"]: token = encode({ "email": email, "role": user["role"], "exp": datetime.utcnow() + timedelta(hours=24) }, os.getenv("JWT_SECRET", Fernet.generate_key().decode()), algorithm="HS256") logger.info("User validated", email=email) return token return None except Exception as e: logger.error("User validation failed", email=email, error=str(e)) return None def validate_token(self, token: str) -> bool: try: payload = decode(token, os.getenv("JWT_SECRET", Fernet.generate_key().decode()), algorithms=["HS256"]) user_data = self.get_secret(f"auth_{payload['email']}") if not user_data: return False user = json.loads(user_data) return payload["role"] in ["admin", "deployer"] except PyJWTError as e: logger.error("Token validation failed", error=str(e)) return False def main() parser = argparse.ArgumentParser(description="WhisperSec Vault Manager") parser.add_argument("--init", action="store_true", help="Initialize vault") parser.add_argument("--add", nargs=2, metavar=('key', 'value'), help="Add secret") args = parser.parse_args() vault = VaultManager() if args.init: vault.save_vault() print("Vault initialized") elif args.add: key, value = args.add vault.store_secret(key, value) print(f"Stored secret: {key}") if __name__ == "__main__': main()

#!/usr/bin/env python3 import psutil import redis import json import time import logging import structlog structlog.configure( processors=[ structlog.processors.TimeStamper(fmt="iso"), structlog.processors.JSONRenderer() ], logger_factory=structlog.stdlib.LoggerFactory(), ) logger = structlog.get_logger() redis_client = redis.Redis(host='redis', port=6379, decode_responses=True) def monitor_system(): try: cpu = psutil.cpu_percent() ram = psutil.virtual_memory().percent redis_client.publish("nova:monitoring", json.dumps({"cpu": cpu, "ram": ram, "timestamp": time.time()})) logger.info("System stats published", cpu=cpu, ram=ram) except Exception as e: logger.error("Monitoring failed", error=str(e)) if __name__ == "__main__": while True: monitor_system() time.sleep(30)

#!/usr/bin/env python3 from flask import Flask, render_template, request, redirect, url_for, jsonify from flask_cors import CORS import requests from datetime import datetime app = Flask(__name__, template_folder='templates', static_folder='static') CORS(app) NOVA_GLOW = { "primary": "#00D4FF", "secondary": "#FF00E4", "accent": "#7B00FF", "background": "#0A0E2A", "card": "rgba(255, 255, 255, 0.1)" } @app.route('/') def dashboard(): token = request.cookies.get('auth_token') if not token: return redirect(url_for('login')) try: metrics = requests.get('http://backend:8000/metrics', headers={'Authorization': f'Bearer {token}'}).json() bots = requests.get('http://backend:8000/api/bots/status', headers={'Authorization': f'Bearer {token}'}).json()['bots'] nodes = requests.get('http://backend:8000/api/nodes', headers={'Authorization': f'Bearer {token}'}).json() except: return redirect(url_for('login') return render_template( 'dashboard.html', metrics=metrics, bots=bots, nodes=nodes, palette=NOVA_GLOW, last_updated=datetime.utcnow().isoformat() ) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': email = request.form.get('email') password = request.form.get('password') try: response = requests.post('http://backend:8000/auth/login', json={'email': email, 'password': password}) if response.status_code == 200: token = response.json()['access_token'] resp = redirect(url_for('dashboard')) resp.set_cookie('auth_token', token) return resp return jsonify({'error': 'Invalid credentials'}), 401 except: return jsonify({'error': 'Login failed'}), 500 return render_template('login.html', palette=NOVA_GLOW) @app.route('/upload', methods=['GET', 'POST']) def upload_bot(): token = request.cookies.get('auth_token') if not token: return redirect(url_for('login')) if request.method == 'POST': file = request.files.get('file') code = request.form.get('code') try: if file: response = requests.post( 'http://backend:8000/api/bots/upload', files={'file': file}, headers={'Authorization': f'Bearer {token}'} ) elif code: response = requests.post( 'http://backend:8000/api/bots/upload', files={'file': ('bot.py', code.encode())}, headers={'Authorization': f'Bearer {token}'} ) else: return jsonify({'error': 'No script provided'}), 400 return jsonify(response.json()), response.status_code except: return jsonify({'error': 'Upload failed'}), 500 return render_template('upload.html', palette=NOVA_GLOW) if __name__ == '__main__': app.run(host='0.0.0.0' port=5000)

#!/usr/bin/env python3 from flask import Flask, render_template, request, redirect, url_for, jsonify from flask_cors import CORS import requests from datetime import datetime app = Flask(__name__, template_folder='templates', static_folder='static') CORS(app) NOVA_GLOW = { "primary": "#00D4FF", "secondary": "#FF00E4", "accent": "#7B00FF", "background": "#0A0E2A", "card": "rgba(255, 255, 255, 0.1)" } @app.route('/') def dashboard(): token = request.cookies.get('auth_token') if not token: return redirect(url_for('login')) try: metrics = requests.get('http://backend:8000/metrics', headers={'Authorization': f'Bearer {token}'}).json() bots = requests.get('http://backend:8000/api/bots/status', headers={'Authorization': f'Bearer {token}'}).json()['bots'] nodes = requests.get('http://backend:8000/api/nodes', headers={'Authorization': f'Bearer {token}'}).json() except: return redirect(url_for('login') return render_template( 'dashboard.html', metrics=metrics, bots=bots, nodes=nodes, palette=NOVA_GLOW, last_updated=datetime.utcnow().isoformat() ) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': email = request.form.get('email') password = request.form.get('password') try: response = requests.post('http://backend:8000/auth/login', json={'email': email, 'password': password}) if response.status_code == 200: token = response.json()['access_token'] resp = redirect(url_for('dashboard')) resp.set_cookie('auth_token', token) return resp return jsonify({'error': 'Invalid credentials'}), 401 except: return jsonify({'error': 'Login failed'}), 500 return render_template('login.html', palette=NOVA_GLOW) @app.route('/upload', methods=['GET', 'POST']) def upload_bot(): token = request.cookies.get('auth_token') if not token: return redirect(url_for('login')) if request.method == 'POST': file = request.files.get('file') code = request.form.get('code') try: if file: response = requests.post( 'http://backend:8000/api/bots/upload', files={'file': file}, headers={'Authorization': f'Bearer {token}'} ) elif code: response = requests.post( 'http://backend:8000/api/bots/upload', files={'file': ('bot.py', code.encode())}, headers={'Authorization': f'Bearer {token}'} ) else: return jsonify({'error': 'No script provided'}), 400 return jsonify(response.json()), response.status_code except: return jsonify({'error': 'Upload failed'}), 500 return render_template('upload.html', palette=NOVA_GLOW) if __name__ == '__main__': app.run(host='0.0.0.0', port=5000)

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Login - Humanitas AI</title> <link href="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"> <style> body { background: {{ palette.background }}; color: #ffffff; font-family: 'Arial', sans-serif; } .glass { background: {{ palette.card }}; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; } </style> </head> <body> <div class="container mx-auto p-4 flex justify-center items-center h-screen"> <div class="glass p-6 w-full max-w-md"> <h1 class="text-2xl font-bold mb-4 text-{{ palette.primary }}">Login</h1> <form method="POST" action="/login"> <label for="email" class="block text-{{ palette.accent }}">Email</label> <input type="email" id="email" name="email" class="w-full p-2 mb-4 bg-{{ palette.card }}-text-white rounded" required> <label for="password" class="block text-{{ palette.accent }}">Password</label> <input type="password" id="password" name="password" class="w-full p-2 mb-4 bg-{{ palette.card }}-text-white rounded" required> <button type="submit" class="bg-{{ palette.secondary }} text-white px-4 py-2 rounded w-full">Login</button> </form> </div> </div> </body> </html>

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial_scale=1.0"> <title>Humanitas AI Dashboard</title> <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"> <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script> <script src="/https://cdn.jsdelivr.net/npm/framer-motion@10.12.4/dist/framer-motion.min.js"></script> <style> body { background: {{ palette.background }}; color: #ffffff; font-family: 'Arial', sans-serif; transition: background 0.3s; } .glass { background: {{ palette.card }}; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px; } .tabs { display: flex; gap: 10px; margin-bottom: 20px; } .tab { padding: 10px 20px; cursor: pointer; border-radius: 5px; } .tab.active { background: {{ palette.primary }}; } .chart-container { height: 300px; } </style> </head> <body> <div class="container mx-auto p-4"> <div h1 class="text-3xl font-bold mb-4 text-{{ palette.primary }}">Humanitas AI Dashboard</h1> <div class="tabs"> <div class="tab active" data-tab="overview">Overview</div> <div class="tab" data-tab="bots">Bots</div> <div class="tab" data-tab="nodes">Nodes</div> </div> <div id="overview" class="tab-content"> <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"> <div class="glass p-4"> <h2 class="text-xl text-{{ palette.accent }}">Metrics</h2> <p>Requests Total: {{ metrics.requests_total | default(0) }}</p> <p>Accounts Created: {{ metrics.accounts_created | default(0) }}</p> <p>Payments Processed: {{ metrics.payments_processed | default(0) }}</p> <p>Listings Active: {{ metrics.listings_active | default(0) }}</p> <p>Orders Fulfilled: {{ metrics.orders_fulfilled | default(0) }}</p> </div> <div class="glass p-4"> <h2 class="text-xl text-{{ palette.accent }}">Node Performance</h2> <p>CPU Usage: {{ metrics.node_cpu | default(0) }}%</p> <p>RAM Usage: {{ metrics.node_ram | default(0) }}%</p> <canvas id="performanceChart" class="chart-container"></canvas> </div> </div> </div> <div id="bots" class="tab-content hidden"> <div class="glass p-4"> <h2 class="text-xl text-{{ palette.accent }}">Bot Status</h2> <canvas id="botChart" class="mb-4 chart-container"></canvas> <table class="w-full"> <thead> <tr><th>Name</th><th>Status</th><th>Execution Time</th><th>Errors</th><th>Last Run</th></tr> </thead> <tbody> {% for bot in bots %} <tr> <td>{{ bot.name %></td> <td>{{ bot.status }}</td> <td>{{ bot.execution_time }}s</td> <td>{{ bot.errors }}</td> <td>{{ bot.last_run }}</td> </tr> {% endfor %} </tbody> </table> </div> </div> <div id="nodes" class="tab-content hidden"> <div class="glass p-4"> <h2 class="text-xl text-{{ palette.accent }}">Nodes</h2> <table class="table w-full"> <thead> <tr><th>ID</th><th>CPU</th><th>RAM</th><th>Last Seen</th></tr> </thead> <tbody> {% for node in nodes %} <tr> <td>{{ node.id }}</td> <td>{{ node.cpu }}%</td> <td>{{ node.ram }}%</td> <td>{{ node.last_seen }}</td> </tr> {% endfor %} </tbody> </table> </div> </div> <a href="/upload" class="mt-4 inline-block bg-blue-500 text-white px-{{ palette.secondary }} px-2 py-2 rounded">Upload Bot</a> </div> <script> // Tab Switching document.querySelectorAll('.tab').forEach(tab => { tab.addEventListener('click', () => { document.querySelectorAll('.tab').forEach(t => t.classList.remove('active')); tab.classList.add('active'); document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden')); document.querySelector(c => c.getElementById(tab.dataset.tab)).classList.remove('hidden'); }); }); // Performance Chart const performanceChart = new Chart(document.getElementById('performanceChart'), { type: 'line', data: { labels: ['CPU', 'RAM'], datasets: [{ label: 'Node Usage', data: [{{ metrics.node_cpu | default(0) }}, {{ metrics.node_ram | default(0) }}], backgroundColor: '{{ palette.primary }}', borderColor: '{{ palette.accent }}' }] } }); // Bot Chart const botChart = new Chart(document.getElementById('botChart'), { type: 'bar', data: { labels: [{% for bot in bots %}'{{ bot.name }}',{% endfor %}], datasets: [{ label: 'Execution Time (s)', data: [{% for bot in bots %}{{ bot.execution_time }},{% endfor %}], backgroundColor: '{{ palette.primary }}' }, { label: 'Errors', data: [{% for bot in bots %}{{ bot.errors }},{% endfor %}], backgroundColor: '{{ palette.secondary }}' }] } }); // WebSocket for real-time updates const ws = new WebSocket('ws://localhost:8000/api/ws/metrics'); ws.onmessage = (event) => { const metrics = JSON.parse(event.data); document.querySelector('p:contains("Requests Total")').textContent = `Requests Total: ${metrics.requests_total}`; performanceChart.data.datasets[0].data = [metrics.node_cpu, metrics.node_ram]; performanceChart.update(); }; </script> </body> </html>

<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <meta name="viewport" content="width=device-width, initial-scale=1.0"> <title>Upload Bot - Humanitas AI</title> <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"> <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs/loader.js"></script> <style> body { background: {{ palette.background }}; color: #ffffff; font-family: 'Arial', sans-serif; } .glass { background: {{ palette.card }}; backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 10px; } #editor { width: 100%; height: 400px; border: 1px solid {{ palette.accent }}; } </style> </head> <body> <div class="container mx-auto p-4"> <h1 class="text-3xl font-bold mb-4 text-{{ palette.primary }}">Upload Bot</h1> <div class="glass p-6"> <form id="uploadForm" enctype="multipart/form-data"> <label class="block text-{{ palette.accent }} mb-2">Upload Bot Script</label> <input type="file" name="file" accept=".py" class="mb-4 w-full p-2 bg-{{ palette.card }} text-white rounded"> <label class="block text-{{ palette.accent }} mb-2">Or Write Code</label> <div id="editor"></div> <button type="submit" class="mt-4 bg-{{ palette.secondary }} text-white px-4 py-2 rounded w-full">Deploy Bot</button> </form> <div id="messages" class="mt-4 text-{{ palette.primary }}"></div> <a href="/" class="mt-4 inline-block text-{{ palette.accent }}">Back to Dashboard</a> </div> </div> <script> require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.33.0/min/vs' }}); require(['vs/editor/editor.main'], function() { const editor = monaco.editor.create(document.getElementById('editor'), { value: '# Write your bot script here\nprint("Hello, Humanitas Bot!")', language: 'python', theme: 'vs-dark' }); document.getElementById('uploadForm').addEventListener('submit', async (e) => { e.preventDefault(); const formData = new FormData(); const fileInput = document.querySelector('input[name="file"]'); const code = editor.getValue(); if (fileInput.files.length > 0) { formData.append('file', fileInput.files[0]); } else if (code.trim()) { formData.append('file', new Blob([code], { type: 'text/plain' }), 'bot.py'); } else { document.getElementById('messages').textContent = 'Please provide a script file or code.'; return; } try { const response = await fetch('/upload', { method: 'POST', body: formData, headers: { 'Authorization': 'Bearer ' + document.cookie.replace(/(?:(?:^|.*;\s*)auth_token\s*\=\s*([^;]*).*$)|^.*$/, "$1") } }); const result = await response.json(); document.getElementById('messages').textContent = response.ok ? result.message : `Error: ${result.error}`; } catch (error) { document.getElementById('messages').textContent = `Failed to deploy bot: ${error.message}`; } }); }); </script> </body> </html>

FROM python:3.11-slim WORKDIR /app RUN apt-get update && apt-get install -y \ chromium \ chromium-driver \ curl \ && rm -rf /var/lib/apt/lists/* COPY requirements.txt . RUN pip install --no-cache-dir -r requirements.txt COPY nova_humanitas_core.py . COPY nova-agent.py . COPY whispersec.py . COPY deploy/ deploy/ COPY frontend/ frontend/ COPY bots/ bots/ EXPOSE 8000 5000 CMD ["sh", "-c", "uvicorn nova_humanitas_core:app --host 0.0.0.0 --port 8000 & gunicorn -w 4 -b 0.0.0.0:5000 frontend.app:app & python nova-agent.py"]

version: '3.8' services: backend: build: . ports: - "8000:8000" environment: - DB_HOST=postgres - REDIS_URL=redis://redis:6379 depends_on: - postgres - redis - ollama volumes: - .:/app networks: - humanitas-net frontend: build: . ports: - "5000:5000" depends_on: - backend networks: - humanitas-net postgres: image: postgres:15 environment: - POSTGRES_USER=${DB_USER} - POSTGRES_PASSWORD=${DB_PASSWORD} - POSTGRES_DB=${DB_NAME} volumes: - postgres_data:/var/lib/postgresql/data networks: - humanitas-net redis: image: redis:7 networks: - humanitas-net celery: build: . command: celery -A nova_humanitas_core:app_celery worker --loglevel=info depends_on: - redis - backend environment: - DB_HOST=postgres - REDIS_URL=redis://redis:6379 volumes: - .:/app networks: - humanitas-net ollama: image: ollama/ollama:latest ports: - "11434:11434" volumes: - ollama_data:/root/.ollama networks: - humanitas-net volumes: postgres_data: ollama_data: networks: humanitas-net: driver: bridge

name: Deploy Humanitas AI on: push: branches: [ main ] workflow_dispatch: jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up SSH run: | mkdir -p ~/.ssh echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519 chmod 600 ~/.ssh/id_ed25519 ssh-keyscan -H ${{ secrets.VPS_IP }} >> ~/.ssh/known_hosts - name: Deploy to VPS run: | ssh -i ~/.ssh/id_ed25519 ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }} << 'EOF' cd /opt/humanitas git pull origin main docker-compose down docker-compose up --build -d EOF - name: Verify Deployment run: | ssh -i ~/.ssh/id_ed25519 ${{ secrets.VPS_USER }}@${{ secrets.VPS_IP }} << 'EOF' docker ps curl -f http://localhost:8000/api/health || exit 1 curl -f http://localhost:5000 || exit 1 EOF

aiohttp==3.9.5 aioredis==2.0.1 asyncpg==0.29.0 bitcoinlib==0.6.13 celery==5.4.0 cryptography==43.0.1 fake-useragent==1.5.1 fastapi==0.115.0 flask==3.0.3 flask-cors==5.0.0 gunicorn==23.0.0 pyjwt==2.9.0 paypalrestsdk==1.13.3 prometheus-client==0.21.0 psutil==6.0.0 pydantic==2.9.2 redis==5.0.8 requests==2.32.3 selenium==4.25.0 slowapi==0.1.9 structlog==24.4.0 stripe==11.1.0 tenacity==9.0.0 textblob==0.18.0.post0 uvicorn==0.31.0 webdriver-manager==4.0.2

DB_USER=postgres DB_PASSWORD=password DB_NAME=humanitas DB_HOST=postgres PAYONEER_API_KEY=your_payoneer_api_key STRIPE_API_KEY=your_stripe_api_key PAYPAL_CLIENT_ID=your_paypal_client_id PAYPAL_CLIENT_SECRET=your_paypal_client_secret CJ_DROPSHIPPING_API_KEY=your_cj_api_key ALIEXPRESS_API_KEY=your_aliexpress_api_key EMAIL_PROVIDER=imap.gmail.com EMAIL_USER=your_email@gmail.com EMAIL_PASS=your_email_password TWILIO_API_KEY=your_twilio_api_key CAPTCHA_API_KEY=your_2captcha_key EBAY_TOKEN_SITE_KEY=your_ebay_token_site_key JWT_SECRET=your_jwt_secret DOMAIN=your_domain.com PAYMENT_METHOD=payoneer FINAL_PAYMENT_METHOD=crypto BTC_WALLET_ADDRESS=your_btc_wallet BTC_WALLET_NAME=humanitas_wallet GROQ_KEY=your_groq_key

humanitas/ ├── nova_humanitas_core.py ├── nova-agent.py ├── whispersec.py ├── deploy/ │ ├── novaghost.py ├── frontend/ │ ├── app.py │ ├── templates/ │ │ ├── dashboard.html │ │ ├── login.html │ │ ├── upload.html │ ├── static/ ├── bots/ ├── Dockerfile ├── docker-compose.yml ├── requirements.txt ├── .env.example ├── .github/ │ ├── workflows/ │ │ ├── deploy.yml